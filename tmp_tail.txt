                } else {
                  // Merge: imported is earlier part; existing is later part -> remove header from later part and concat
                  const existing = await downloadAppDataFileBase64(current.id, { interactive: true });
                  const exText = atob(existing.contentB64);
                  const exLines = exText.split('\n');
                  const exBody = exLines.slice(1).join('\n');
                  const merged = importedText.replace(/\n*$/, '\n') + exBody;
                  await upsertAppDataTextFile(baseName, merged, { interactive: true });
                }
              } else if (f.name.startsWith('snapshots/')) {
                await upsertAppDataTextFile(f.name, atob(f.contentB64), { interactive: true });
              }
            }
            // Delete cutoff marker after successful import
            await deleteAppDataFile(chosen.id);
            sendResponse?.({ ok: true });
          } catch (e: any) {
            sendResponse?.({ ok: false, error: e?.message || String(e) });
          }
        } catch (e: any) {
          sendResponse?.({ ok: false, error: e?.message || String(e) });
        }
      } else if ((raw as any)?.type === 'backup/restore/dryRun') {
        try {
          const { name, snapshot, mode, apply, passphrase } = (raw as any).payload || {};
          let snap: SettingsSnapshot | null = null;
          if (snapshot && typeof snapshot === 'object') snap = snapshot as SettingsSnapshot;
          else if (name && typeof name === 'string') snap = await downloadSnapshotByName(String(name), { passphrase: passphrase || undefined });
          else snap = await restoreSettings({ passphrase: passphrase || undefined }); // fallback to settings.json
          if (!snap) { sendResponse?.({ ok: false, error: 'Snapshot not found' }); return; }
          const res = await dryRunRestoreApply(snap, (mode === 'overwrite' ? 'overwrite' : 'merge'), apply || {});
          sendResponse?.({ ok: true, summary: res });
        } catch (e: any) {
          sendResponse?.({ ok: false, error: e?.message || String(e) });
        }
      } else if ((raw as any)?.type === 'backup/restore/apply') {
        try {
          const { name, snapshot, mode, apply, passphrase } = (raw as any).payload || {};
          let snap: SettingsSnapshot | null = null;
          if (snapshot && typeof snapshot === 'object') snap = snapshot as SettingsSnapshot;
          else if (name && typeof name === 'string') snap = await downloadSnapshotByName(String(name), { passphrase: passphrase || undefined });
          else snap = await restoreSettings({ passphrase: passphrase || undefined }); // fallback to settings.json
          if (!snap) { sendResponse?.({ ok: false, error: 'Snapshot not found' }); return; }
          const res = await applyRestore(snap, (mode === 'overwrite' ? 'overwrite' : 'merge'), apply || {});
          // Notify and backup
          try { chrome.runtime.sendMessage({ type: 'db/change', payload: { entity: 'tags' } }); } catch {}
          try { chrome.runtime.sendMessage({ type: 'db/change', payload: { entity: 'groups' } }); } catch {}
          try { chrome.runtime.sendMessage({ type: 'db/change', payload: { entity: 'videos' } }); } catch {}
          try { chrome.runtime.sendMessage({ type: 'db/change', payload: { entity: 'channels' } }); } catch {}
          queueCommitFlush(3000);
          queueSettingsBackup();
          sendResponse?.({ ok: true, summary: res });
        } catch (e: any) {
          sendResponse?.({ ok: false, error: e?.message || String(e) });
        }
      }
    } catch (e: any) {
      derr('bg handler error:', e?.message || e);
      sendResponse?.({ ok: false, error: e?.message || String(e) });
    }
  })();

  // IMPORTANT: keep the response channel open for async work
  return true;
});
self.addEventListener('unhandledrejection', (ev: any) => derr('unhandledrejection', ev?.reason));
self.addEventListener('error', (ev: any) => derr('error', ev?.message || ev));

async function getApiKey(): Promise<string | null> {
  return new Promise((resolve) => {
    try { chrome.storage?.local?.get('ytApiKey', (o) => resolve((o?.ytApiKey as string) || null)); }
    catch { resolve(null); }
  });
}

async function listVideoIds(opts: { skipFetched: boolean }): Promise<string[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('videos', 'readonly');
    const os = tx.objectStore('videos');
    const cur = os.openCursor();
    const ids: string[] = [];
    cur.onsuccess = () => {
      const c = cur.result as IDBCursorWithValue | null;
      if (!c) { resolve(ids); return; }
      const row: any = c.value;
      if (!opts.skipFetched || !row?.fetchedAt) ids.push(row?.id);
      c.continue();
    };
    cur.onerror = () => reject(cur.error);
  });
}

function sleep(ms: number) { return new Promise(res => setTimeout(res, ms)); }

function bestThumb(thumbs: any): string | null {
  try {
    return (thumbs?.high?.url || thumbs?.medium?.url || thumbs?.default?.url || null) as (string | null);
  } catch { return null; }
}
function trimText(s: string, max: number = 1000): string { return (s || '').length > max ? (s || '').slice(0, max) + 'â€¦' : (s || ''); }

async function fetchVideosListWithRetry(parts: string, ids: string[], apiKey: string): Promise<any[]> {
  const url = new URL('https://www.googleapis.com/youtube/v3/videos');
  url.searchParams.set('part', parts);
  url.searchParams.set('id', ids.join(','));
  url.searchParams.set('key', apiKey);
  const maxAttempts = 3;
  let attempt = 0;
  let lastErr: any = null;
  while (attempt < maxAttempts) {
    try {
      const resp = await fetch(String(url));
      if (!resp.ok) {
        let detail = '';
        try { detail = await resp.text(); } catch { /* ignore */ }
        throw new Error(`videos.list ${resp.status} ${resp.statusText}${detail ? ' - ' + detail.slice(0, 240) : ''}`);
      }
      const data = await resp.json();
      const items = Array.isArray((data as any)?.items) ? (data as any).items : [];
      return items;
    } catch (e) {
      lastErr = e;
      attempt += 1;
      if (attempt >= maxAttempts) break;
      await sleep(500 * attempt * attempt); // 0.5s, 2s
    }
  }
  throw (lastErr || new Error('videos.list failed after retries'));
}

async function fetchChannelsListWithRetry(parts: string, ids: string[], apiKey: string): Promise<any[]> {
  const url = new URL('https://www.googleapis.com/youtube/v3/channels');
  url.searchParams.set('part', parts);
  url.searchParams.set('id', ids.join(','));
  url.searchParams.set('key', apiKey);
  const maxAttempts = 3;
  let attempt = 0;
  let lastErr: any = null;
  while (attempt < maxAttempts) {
    try {
      const resp = await fetch(String(url));
      if (!resp.ok) {
        let detail = '';
        try { detail = await resp.text(); } catch { /* ignore */ }
        throw new Error(`channels.list ${resp.status} ${resp.statusText}${detail ? ' - ' + detail.slice(0, 240) : ''}`);
      }
      const data = await resp.json();
      const items = Array.isArray((data as any)?.items) ? (data as any).items : [];
      return items;
    } catch (e) {
      lastErr = e;
      attempt += 1;
      if (attempt >= maxAttempts) break;
      await sleep(500 * attempt * attempt);
    }
  }
  throw (lastErr || new Error('channels.list failed after retries'));
}

async function listDistinctChannelIds(): Promise<string[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('videos', 'readonly');
    const os = tx.objectStore('videos');
    const idx = os.index('byChannel');
    const set = new Set<string>();
    const cur = idx.openCursor();
    cur.onsuccess = () => {
      const c = cur.result as IDBCursorWithValue | null;
      if (!c) { resolve(Array.from(set)); return; }
      const row: any = c.value;
      const chId = row?.channelId;
      if (chId) set.add(chId);
      c.continue();
    };
    cur.onerror = () => reject(cur.error);
  });
}

async function channelIdsForVideos(ids: string[]): Promise<string[]> {
  const set = new Set<string>();
  const db = await openDB();
  await new Promise<void>((resolve, reject) => {
    const tx = db.transaction('videos', 'readonly');
    const os = tx.objectStore('videos');
    (async () => {
      for (const id of ids) {
        await new Promise<void>((res, rej) => {
          const g = os.get(id);
          g.onsuccess = () => { const row: any = g.result; if (row?.channelId) set.add(row.channelId); res(); };
          g.onerror = () => rej(g.error);
        });
      }
    })().then(() => (tx as any).commit?.());
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
  return Array.from(set);
}
